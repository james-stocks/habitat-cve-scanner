require 'fileutils'
require 'git'
require 'json'
require 'net/http'
require 'open-uri'

# @param habitat_version  string
# @param cve_product_data hash of CVE affected product data
# @return true if the habitat version matches any of the CVE version expressions 
def affected?(habitat_version, cve_product_data)
  # Check for specific versions
  exact_versions = cve_product_data.dig('version', 'version_data').select { |x| x['version_affected'] == '=' }.map { |x| x['version_value'] }
  return true if exact_versions.include? habitat_version
  # Check for <= cases
  less_or_equal_versions = cve_product_data.dig('version', 'version_data').select { |x| x['version_affected'] == '<=' }.map { |x| x['version_value'] }
  less_or_equal_versions.select { |x| habitat_version <= x }.any?
end


FileUtils.remove_dir('tmp') if File.directory?('tmp')
FileUtils.mkdir_p 'tmp'

# Fetch metadata for Recent feed
current_metadata = Net::HTTP.get(URI('https://nvd.nist.gov/feeds/json/cve/1.0/nvdcve-1.0-recent.meta'))
current_sha = current_metadata.strip.split.select { |x| x =~ /^sha256\:/ }.first.split(':')[-1]

# Compare metadata to last run, exit if unchanged
if File.exist?('last_recent_feed.txt')
  last_sha = File.read('last_recent_feed.txt').strip.split.select { |x| x =~ /^sha256\:/ }.first.split(':')[-1]
  if last_sha == current_sha
    puts "No change since last time the feed was checked (SHA256: #{current_sha})"
    exit 0
  end
end

# Fetch latest update
current_cve_json = nil
File.open('tmp/current_cv.gz', 'w') do |f|
  f.write(open('https://nvd.nist.gov/feeds/json/cve/1.0/nvdcve-1.0-recent.json.gz').read)
end
Zlib::GzipReader.open('tmp/current_cv.gz') do |z|
  current_cve_json = JSON.parse(z.read)
end

# clone latest core-plans
Git.clone('https://github.com/habitat-sh/core-plans.git', 'tmp/core-plans') unless File.directory?('tmp/core-plans')

# Compare each CVE with habitat plans
cves_no_product_match = []
cves_version_not_affected = []
cves_affected = []

cve_entries = current_cve_json['CVE_Items']
cve_entries.each do |cve|
  id = cve.dig('cve', 'CVE_data_meta', 'ID')
  if cve.dig('cve', 'affects', 'vendor', 'vendor_data').any?
    product_match_found = false
    version_match_found = false
    found_but_no_version_match = false
    # iterate on vendors and products for this CVE
    cve.dig('cve', 'affects', 'vendor', 'vendor_data').each do |cve_vendor_data|
      cve_vendor_data.dig('product', 'product_data').each do |cve_product_data|
        cve_product_name = cve_product_data['product_name']
        # TODO: Just matching CVE name with Habitat plan name is presumptious. May need additional step to map CVE vendor_name and product_name to hab plan names.
        if cve_product_name && File.directory?("tmp/core-plans/#{cve_product_name}")
          product_match_found = true
          habitat_version = File.read("tmp/core-plans/#{cve_product_name}/plan.sh").split.detect { |x| x =~ /^pkg_version/}.split('=')[-1]
          if affected?(habitat_version, cve_product_data)
            version_match_found = true
            cves_affected << [id, cve_product_name]
          end
        end
      end
    end
    if product_match_found
      cves_version_not_affected << id unless version_match_found
    else
      cves_no_product_match << id
    end
  else
    cves_no_product_match << id
  end
end

puts "Checked #{cve_entries.count} CVEs."
puts "#{cves_no_product_match.count} CVEs do not match a Habitat plan."
puts "#{cves_version_not_affected.count} CVEs affect software there is a core plan for, but the current version of the core plan is not affected."
if cves_affected.any?
  puts "#{cves_affected.count} CVEs affect current core plans!\n\n"
  puts "CVE ID       | Core plan"
  cves_affected.each do |cve|
    puts "#{cve[0]} #{cve[1]}"
  end
end

# Output current metadata as the last_recent_feed.json file
File.open('last_recent_feed.txt', 'w') do |f|
  f.write(current_metadata)
end

